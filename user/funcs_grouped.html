<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" href="github.css">
</head>
<body>
<table class="nav-table">
    <tr>
        <td class="nav-left">&lArr;&nbsp;<a href="funcs_dataframe.html">SMV DataFrame Functions</a></td>
        <td class="nav-center"><a href="0_user_toc.html">Table Of Contents</a></td>
        <td class="nav-right"><a href="dqm.html">Validation & Data Quality Management (DQM)</a>&nbsp;&rArr;</td>
    </tr>
</table>
<hr>

<article class="markdown-body">
<h1 id="smv-group-helper-functions">SMV Group Helper Functions</h1>
<p>TODO: group helper functions docs should just be a pointer to API doc with exmaples below!<br />TODO: extract out pivot operations into own section (because they span group/df ops)</p>
<h3 id="aggwithkeys">aggWithKeys</h3>
<p>Same as agg, but by default, keep all the keys.</p>
<p>Example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">groupBy</span>(<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>).<span class="fu">aggWithKeys</span>(<span class="fu">sum</span>(<span class="st">&quot;x&quot;</span>) as <span class="st">&quot;x&quot;</span>)</code></pre>
<p>will output 3 columns: <code>a</code>, <code>b</code> and <code>x</code>.</p>
<h3 id="pivot-operations">Pivot Operations</h3>
<p>We may often need to &quot;flatten out&quot; the normalized data for easy manipulation. Rather than create custom code for each pivot required, user should use the smvPivot functions in SMV.</p>
<p>For Example:</p>
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">month</th>
<th align="right">product</th>
<th align="left">count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">5/14</td>
<td align="right">A</td>
<td align="left">100</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">6/14</td>
<td align="right">B</td>
<td align="left">200</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">5/14</td>
<td align="right">B</td>
<td align="left">300</td>
</tr>
</tbody>
</table>
<p>We would like to generate a single row for each unique id but still maintain the full granularity of the data. The desired output is:</p>
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">count_5_14_A</th>
<th align="left">count_5_14_B</th>
<th align="left">count_6_14_A</th>
<th align="left">count_6_14_B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">100</td>
<td align="left">300</td>
<td align="left">NULL</td>
<td align="left">200</td>
</tr>
</tbody>
</table>
<p>The raw input is divided into 4 parts.</p>
<ul>
<li>key column: part of the primary key that is preserved in the output. That would be the <code>id</code> column in the above example.<br /></li>
<li>pivot columns: the columns whose row values will become the new column names. The cross product of all unique values for <em>each</em> column is used to generate the output column names.<br /></li>
<li>value columns: the value that will be copied/aggregated to corresponding output column. <code>count</code> in our example.<br /></li>
<li>output postfix: the list of postfix for the pivoted column. &quot;5_14_A&quot;, &quot;5_14_B&quot;, &quot;6_14_A&quot;, &quot;6_14_B&quot; in our example.</li>
</ul>
<p>The command to transform the above data is:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">smvGroupBy</span>(<span class="st">&quot;id&quot;</span>).<span class="fu">smvPivotSum</span>(Seq(<span class="st">&quot;month&quot;</span>, <span class="st">&quot;product&quot;</span>))(<span class="st">&quot;count&quot;</span>)(<span class="st">&quot;5_14_A&quot;</span>, <span class="st">&quot;5_14_B&quot;</span>, <span class="st">&quot;6_14_A&quot;</span>, <span class="st">&quot;6_14_B&quot;</span>))</code></pre>
<p><em>Note:</em> multiple pivot column sequences and value columns may be specified.</p>
<p>There are actually a group of functions on both DataFrame and SmvGroupedData to make the Pivot operation flexible.</p>
<ul>
<li>smvPivot on DF<br /></li>
<li>smvPivot on SmvGroupedData<br /></li>
<li>smvPivotSum on SmvGroupedData</li>
</ul>
<h4 id="smvpivot-on-df">smvPivot on DF</h4>
<p>smvPivot on DF will output 1 record per input record, and all input fields are kept.</p>
<p>Client code looks like</p>
<pre class="sourceCode scala"><code class="sourceCode scala">   df.<span class="fu">smvPivot</span>(Seq(<span class="st">&quot;month&quot;</span>, <span class="st">&quot;product&quot;</span>))(<span class="st">&quot;count&quot;</span>)(<span class="st">&quot;5_14_A&quot;</span>, <span class="st">&quot;5_14_B&quot;</span>, <span class="st">&quot;6_14_A&quot;</span>, <span class="st">&quot;6_14_B&quot;</span>)</code></pre>
<p>Input</p>
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">month</th>
<th align="left">product</th>
<th align="left">count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">5/14</td>
<td align="left">A</td>
<td align="left">100</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">6/14</td>
<td align="left">B</td>
<td align="left">200</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">5/14</td>
<td align="left">B</td>
<td align="left">300</td>
</tr>
</tbody>
</table>
<p>Output</p>
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">month</th>
<th align="left">product</th>
<th align="left">count</th>
<th align="left">count_5_14_A</th>
<th align="left">count_5_14_B</th>
<th align="left">count_6_14_A</th>
<th align="left">count_6_14_B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">5/14</td>
<td align="left">A</td>
<td align="left">100</td>
<td align="left">100</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">6/14</td>
<td align="left">B</td>
<td align="left">200</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">200</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">5/14</td>
<td align="left">B</td>
<td align="left">300</td>
<td align="left">NULL</td>
<td align="left">300</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
</tr>
</tbody>
</table>
<h4 id="smvpivot-on-gd">smvPivot on GD</h4>
<pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">groupBy</span>(<span class="st">&quot;id&quot;</span>).<span class="fu">smvPivot</span>(
    Seq(<span class="st">&quot;month&quot;</span>, <span class="st">&quot;product&quot;</span>))(
    <span class="st">&quot;count&quot;</span>)(
    <span class="st">&quot;5_14_A&quot;</span>, <span class="st">&quot;5_14_B&quot;</span>, <span class="st">&quot;6_14_A&quot;</span>, <span class="st">&quot;6_14_B&quot;</span>)</code></pre>
<p>Output</p>
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">count_5_14_A</th>
<th align="left">count_5_14_B</th>
<th align="left">count_6_14_A</th>
<th align="left">count_6_14_B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">100</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
<td align="left">200</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">NULL</td>
<td align="left">300</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
</tr>
</tbody>
</table>
<p>Content-wise returns the similar thing as the DataFrame version without unspecified columns. Also has 1-1 map between input<br />and output. But the output of it is a GroupedData object (actually SmvGroupedData), so you can do</p>
<pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">groupBy</span>(&#39;id).<span class="fu">smvPivot</span>(...)(...)(...).<span class="fu">sum</span>(<span class="st">&quot;count_5_14_A&quot;</span>, <span class="st">&quot;count_6_14_B&quot;</span>)</code></pre>
<p>or other aggregate functions with <code>agg</code>.</p>
<p>A convienience function is</p>
<pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">groupBy</span>(<span class="st">&quot;id&quot;</span>).<span class="fu">smvPivotSum</span>(Seq(<span class="st">&quot;month&quot;</span>, <span class="st">&quot;product&quot;</span>))(<span class="st">&quot;count&quot;</span>)(<span class="st">&quot;5_14_A&quot;</span>, <span class="st">&quot;5_14_B&quot;</span>, <span class="st">&quot;6_14_A&quot;</span>, <span class="st">&quot;6_14_B&quot;</span>)</code></pre>
<p>It will sum on all derived columns.</p>
<p>Output</p>
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">count_5_14_A</th>
<th align="left">count_5_14_B</th>
<th align="left">count_6_14_A</th>
<th align="left">count_6_14_B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">100</td>
<td align="left">300</td>
<td align="left">NULL</td>
<td align="left">200</td>
</tr>
</tbody>
</table>
<h4 id="multiple-pivot-column-sets">Multiple Pivot Column Sets</h4>
<p>You can actually specify multiple pivot column sets in a Pivot Operation as below:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">smvPivot</span>(Seq(<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>), Seq(<span class="st">&quot;a&quot;</span>))......</code></pre>
<p>It will pivot on value of <code>a</code> and the combination of <code>a</code>, <code>b</code> values separately.</p>
<p>For example:<br />Input</p>
<table>
<thead>
<tr class="header">
<th align="left">k1</th>
<th align="left">k2</th>
<th align="left">p</th>
<th align="left">v1</th>
<th align="left">v2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">x</td>
<td align="left">A</td>
<td align="left">10</td>
<td align="left">100.5</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">y</td>
<td align="left">A</td>
<td align="left">10</td>
<td align="left">100.5</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">x</td>
<td align="left">A</td>
<td align="left">20</td>
<td align="left">200.5</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">x</td>
<td align="left">A</td>
<td align="left">10</td>
<td align="left">200.5</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">x</td>
<td align="left">B</td>
<td align="left">50</td>
<td align="left">200.5</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">x</td>
<td align="left">A</td>
<td align="left">60</td>
<td align="left">500.0</td>
</tr>
</tbody>
</table>
<pre class="sourceCode scala"><code class="sourceCode scala">    <span class="kw">val</span> res = srdd.<span class="fu">smvGroupBy</span>(&#39;k1).<span class="fu">smvPivot</span>(Seq(<span class="st">&quot;k2&quot;</span>), Seq(<span class="st">&quot;k2&quot;</span>, <span class="st">&quot;p&quot;</span>))(<span class="st">&quot;v2&quot;</span>)(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;x_A&quot;</span>, <span class="st">&quot;y_B&quot;</span>).<span class="fu">agg</span>(
      $<span class="st">&quot;k1&quot;</span>,
      <span class="fu">countDistinct</span>(<span class="st">&quot;v2_x&quot;</span>) as &#39;dist_cnt_v2_x,
      <span class="fu">countDistinct</span>(<span class="st">&quot;v2_x_A&quot;</span>) as &#39;dist_cnt_v2_x_A,
      <span class="fu">countDistinct</span>(<span class="st">&quot;v2_y_B&quot;</span>) as &#39;dist_cnt_v2_y_B
    )</code></pre>
<p>Output</p>
<table>
<thead>
<tr class="header">
<th align="left">k1</th>
<th align="left">dist_cnt_v2_x</th>
<th align="left">dist_cnt_v2_x_A</th>
<th align="left">dist_cnt_v2_y_B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
</tbody>
</table>
<h3 id="rollupcube-operations">Rollup/Cube Operations</h3>
<p>The <code>smvRollup</code> and <code>smvCube</code> operations add standard rollup/cube operations to a DataFrame. By default, the &quot;*&quot; string is used as the sentinel value (hardcoded at this point). For example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">smvRollup</span>(<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>).<span class="fu">agg</span>(<span class="fu">sum</span>(<span class="st">&quot;d&quot;</span>) as <span class="st">&quot;d&quot;</span>)</code></pre>
<p>The above will create a <em>rollup</em> of the (a,b,c) columns. In essance, calculate the <code>Sum(d)</code> for (a,b,c), (a,b), and (a).</p>
<pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">smvCube</span>(<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>).<span class="fu">agg</span>(<span class="fu">sum</span>(<span class="st">&quot;d&quot;</span>) as <span class="st">&quot;d&quot;</span>)</code></pre>
<p>The above will create <em>cube</em> from the (a,b,c) columns. It will calculate the <code>Sum(d)</code> for (a,b,c), (a,b), (a,c), (b,c), (a), (b), (c)<br /><em>Note:</em> the cube for the global () selection is never computed.</p>
<p>Both methods above have a version on <code>SmvGroupedData</code> that allows the user to provide a set of fixed columns.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">smvGroupBy</span>(<span class="st">&quot;x&quot;</span>).<span class="fu">smvCube</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>).<span class="fu">agg</span>(<span class="fu">sum</span>(<span class="st">&quot;d&quot;</span>) as <span class="st">&quot;d&quot;</span>)</code></pre>
<p>The output will be grouped on (x,a,b,c) instead of just (a,b,c) as as the case with normal cube function.</p>
<p>Example:</p>
<p>Input</p>
<table>
<thead>
<tr class="header">
<th align="left">a</th>
<th align="left">b</th>
<th align="left">c</th>
<th align="left">d</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">a1</td>
<td align="left">b1</td>
<td align="left">c1</td>
<td align="left">10</td>
</tr>
<tr class="even">
<td align="left">a1</td>
<td align="left">b1</td>
<td align="left">c1</td>
<td align="left">20</td>
</tr>
<tr class="odd">
<td align="left">a1</td>
<td align="left">b2</td>
<td align="left">c2</td>
<td align="left">30</td>
</tr>
<tr class="even">
<td align="left">a1</td>
<td align="left">b2</td>
<td align="left">c3</td>
<td align="left">40</td>
</tr>
<tr class="odd">
<td align="left">a2</td>
<td align="left">b3</td>
<td align="left">c4</td>
<td align="left">50</td>
</tr>
</tbody>
</table>
<pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">smvRollup</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>).<span class="fu">aggWithKeys</span>(<span class="fu">sum</span>(<span class="st">&quot;d&quot;</span>) as <span class="st">&quot;sum_d&quot;</span>)</code></pre>
<p>Output</p>
<table>
<thead>
<tr class="header">
<th align="left">a</th>
<th align="left">b</th>
<th align="left">c</th>
<th align="left">sum_d</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">a1</td>
<td align="left">b2</td>
<td align="left">c2</td>
<td align="left">30</td>
</tr>
<tr class="even">
<td align="left">a1</td>
<td align="left">b2</td>
<td align="left">c3</td>
<td align="left">40</td>
</tr>
<tr class="odd">
<td align="left">a2</td>
<td align="left">b3</td>
<td align="left">c4</td>
<td align="left">50</td>
</tr>
<tr class="even">
<td align="left">a1</td>
<td align="left">*</td>
<td align="left">*</td>
<td align="left">100</td>
</tr>
<tr class="odd">
<td align="left">a1</td>
<td align="left">b1</td>
<td align="left">*</td>
<td align="left">30</td>
</tr>
<tr class="even">
<td align="left">a1</td>
<td align="left">b2</td>
<td align="left">*</td>
<td align="left">70</td>
</tr>
<tr class="odd">
<td align="left">a2</td>
<td align="left">b3</td>
<td align="left">*</td>
<td align="left">50</td>
</tr>
<tr class="even">
<td align="left">a1</td>
<td align="left">b1</td>
<td align="left">c1</td>
<td align="left">30</td>
</tr>
<tr class="odd">
<td align="left">a2</td>
<td align="left">*</td>
<td align="left">*</td>
<td align="left">50</td>
</tr>
</tbody>
</table>
<h3 id="quantile-operations">Quantile operations</h3>
<p>The <code>smvQuantile</code> method will compute the quantile (bin number) for each group within the source DataFrame.<br />The algorithm assumes there are group keys and a <code>VALUE</code> column</p>
<ul>
<li>group keys are the ids used to segment the input before computing the quantiles.<br /></li>
<li>the value column is the column that the quantile bins will be computed. This column must be numeric that can be converted to <code>Double</code><br />The output will contain three additional columns, <code>value_total</code>, <code>value_rsum</code>, and <code>value_quantile</code> for the total of the value column, the running sum of the value column, and the quantile of the value respectively.</li>
</ul>
<p>A helper method <code>smvDecile</code> is provided as a shorthand for a quantile with 10 bins.</p>
<p>Example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">smvGroupBy</span>(&#39;g, &#39;g2).<span class="fu">smvQuantile</span>(<span class="st">&quot;v&quot;</span>, <span class="dv">100</span>)</code></pre>
<p>The above will compute the percentile for each group in <code>df</code> grouped by <code>g</code> and <code>g2</code>. Three additional columns will be produced: <code>v_total</code>, <code>v_rsum</code>, and <code>v_quantile</code>.</p>
<h3 id="smvtopnrecs">smvTopNRecs</h3>
<p>For each group, return the top N records according to an ordering</p>
<p>Example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  df.<span class="fu">smvGroupBy</span>(<span class="st">&quot;id&quot;</span>).<span class="fu">smvTopNRecs</span>(<span class="dv">3</span>, $<span class="st">&quot;amt&quot;</span>.<span class="fu">desc</span>)</code></pre>
<p>Will keep the 3 largest <code>amt</code> records for each <code>id</code>.</p>
<h3 id="oneagg-runagg">oneAgg &amp; runAgg</h3>
<p>Please see <a href="CDS_GDO.html">SmvCDS document</a>.</p>
</article>
</body>
</html>
