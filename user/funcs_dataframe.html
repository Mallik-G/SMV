<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" href="github.css">
</head>
<body>
<table class="nav-table">
    <tr>
        <td class="nav-left">&lArr;&nbsp;<a href="funcs_column.html">SMV Column Functions</a></td>
        <td class="nav-center"><a href="0_user_toc.html">Table Of Contents</a></td>
        <td class="nav-right"><a href="funcs_grouped.html">SMV Group Functions</a>&nbsp;&rArr;</td>
    </tr>
</table>
<hr>

<article class="markdown-body">
<h1 id="smv-dataframe-helper-functions">SMV DataFrame Helper Functions</h1>
<p>TODO: should df helper functions just be a pointer to API doc with exmaples below?</p>
<h3 id="saveascsvwithschema">saveAsCsvWithSchema</h3>
<p>Eg.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">saveAsCsvWithSchema</span>(<span class="st">&quot;output/test.csv&quot;</span>)</code></pre></div>
<h3 id="dumpsrdd">dumpSRDD</h3>
<p>Similar to <code>show()</code> method of DF from Spark 1.3, although the format is slightly different.<br />
Since we have this one in place from the past and typically only used in interactive shell, and<br />
also for creating test cases, this function's format is more convenience for<br />
out test case creation.</p>
<h3 id="selectplus">selectPlus</h3>
<p>Adding columns to existing columns (at the tail of the existing columns).</p>
<p>Eg.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">selectPlus</span>($<span class="st">&quot;amt&quot;</span>.<span class="fu">smvSafeDiv</span>($<span class="st">&quot;count&quot;</span>, <span class="fl">0.0</span>) as <span class="st">&quot;price&quot;</span>)</code></pre></div>
<h3 id="selectplusprefix">selectPlusPrefix</h3>
<p>Same as <code>selectPlus</code>, but put the the new column at the beginning of the existing<br />
columns.</p>
<h3 id="selectminus">selectMinus</h3>
<p>Remove a column</p>
<p>Eg.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">selectMinus</span>(<span class="st">&quot;toBeRemoved&quot;</span>)
df.<span class="fu">selectMinus</span>(&#39;toBeRemoved2)</code></pre></div>
<h3 id="renamefield">renameField</h3>
<p>The <code>renameField</code> allows to rename a single or multiple fields of a given schemaRDD.<br />
Given a DataFrame that has the following fields: a, b, c, d one can rename the &quot;a&quot; and &quot;c&quot; fields to &quot;aa&quot; and &quot;cc&quot; as follow</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">renameField</span>(&#39;a -&gt; &#39;aa, &#39;c -&gt; &#39;cc)</code></pre></div>
<p>or</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">renameField</span>(<span class="st">&quot;a&quot;</span> -&gt; <span class="st">&quot;aa&quot;</span>, <span class="st">&quot;c&quot;</span> -&gt; <span class="st">&quot;cc&quot;</span>)</code></pre></div>
<p>Now the DF will have the following fields: aa, b, cc, d</p>
<h3 id="joinbykey">joinByKey</h3>
<p>Since <code>join</code> operation does not check column name duplication and inconvience to join 2 DFs<br />
with the same key name, we create this helper function.</p>
<p>Eg.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df1.<span class="fu">joinByKey</span>(df2, Seq(<span class="st">&quot;k&quot;</span>), <span class="st">&quot;inner&quot;</span>)</code></pre></div>
<p>If both df1 and df2 have column with name &quot;v&quot;, both will be kept, but the df2 version<br />
will be renamed as &quot;_v&quot;. Only one copy of keys will be kept.</p>
<h3 id="dedupbykey">dedupByKey</h3>
<p>The <code>dedupByKey</code> operation eliminate duplicate records on the primary key. It just arbitrarily picks the first record for a given key or keys combo.</p>
<p>Given the following DataFrame:</p>
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">product</th>
<th align="left">Company</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">A</td>
<td align="left">C1</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">C</td>
<td align="left">C2</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">B</td>
<td align="left">C3</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">B</td>
<td align="left">C4</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">debupByKey</span>(&#39;id)</code></pre></div>
<p>will yield the following dataset:</p>
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">product</th>
<th align="left">Company</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">A</td>
<td align="left">C1</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">B</td>
<td align="left">C3</td>
</tr>
</tbody>
</table>
<p>while</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">debupByKey</span>(&#39;id, &#39;product)</code></pre></div>
<p>will yield the following dataset:</p>
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">product</th>
<th align="left">Company</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">A</td>
<td align="left">C1</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">C</td>
<td align="left">C2</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">B</td>
<td align="left">C3</td>
</tr>
</tbody>
</table>
<h3 id="smvrank">smvRank</h3>
<p>Add a rank/sequence column to a DataFrame.</p>
<p>It uses <code>zipWithIndex</code> method of <code>RDD</code> to add a sequence number to records in a DF. It ranks records one partition by another. Please refer to Spark's document for the detail behavior of <code>zipWithIndex</code>.</p>
<p>Eg.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">smvRank</span>(<span class="st">&quot;seqId&quot;</span>, 0L)</code></pre></div>
<p>It will create a new column with name &quot;seqId&quot; and start from 0L.</p>
<h3 id="smvoverlapcheck">smvOverlapCheck</h3>
<p>For a set of DFs, which share the same key column, check the overlap across them.</p>
<p>Eg.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df1.<span class="fu">smvOverlapCheck</span>(<span class="st">&quot;key&quot;</span>)(df2, df3, df4)</code></pre></div>
<p>The output is another DF with 2 columns:</p>
<pre><code>key
flag</code></pre>
<p>where flag is a bit string, e.g. 0110. Each bit represent whether the original DF has this key.</p>
<p>It can be used with EDD to summarize on the flag:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df1.<span class="fu">smvOverlapCheck</span>(<span class="st">&quot;key&quot;</span>)(df2, df3).<span class="fu">edd</span>.<span class="fu">addHistogramTasks</span>(<span class="st">&quot;flag&quot;</span>)().<span class="fu">Dump</span></code></pre></div>
<h3 id="smvhashsample">smvHashSample</h3>
<p>Sample the df according to the hash of a column.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">smvHashSample</span>($<span class="st">&quot;key&quot;</span>, rate=<span class="fl">0.1</span>, seed=<span class="dv">123</span>)</code></pre></div>
<p>where rate is ranged <code>(0, 1]</code>, seed is an Int. Both has default values, rate defaults to<br />
0.01 (1%), seed defaults to 23</p>
<p>MurmurHash3 is used for generating the hash</p>
<p>If you need to hash on multiple columns, just concatenate them as the following</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">df.<span class="fu">smvHashSample</span>(<span class="fu">smvStrCat</span>($<span class="st">&quot;k1&quot;</span>.<span class="fu">cast</span>(<span class="st">&quot;string&quot;</span>), $<span class="st">&quot;k2&quot;</span>), <span class="fl">0.1</span>)</code></pre></div>
<h3 id="smvpivot-smvcube-smvrollup">smvPivot, smvCube, smvRollup</h3>
<p>Please see the &quot;SmvGroupedData Functions&quot; session</p>
</article>
</body>
</html>
