<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" href="github.css">
</head>
<body>
<table class="nav-table">
    <tr>
        <td class="nav-left">&lArr;&nbsp;<a href="smv_entity_matcher.html">Fuzzy matching between two datasets</a></td>
        <td class="nav-center"><a href="0_user_toc.html">Table Of Contents</a></td>
        <td class="nav-right"><a href="smv_desc_label.html">Column level Description and Labels</a>&nbsp;&rArr;</td>
    </tr>
</table>
<hr>

<article class="markdown-body">
<h1 id="smvancillary">SmvAncillary</h1>
<p>An SMV Ancillary is a collection of data plus methods. Each Ancillary depends on one or more <code>SmvModuleLink</code>s.</p>
<h2 id="smvhierarchies">SmvHierarchies</h2>
<p><code>SmvHierarchies</code> extends <code>SmvAncillary</code>, which provides hierarchy map data, hierarchy structures,<br />
and methods to perform hierarchy aggregation.</p>
<p>It is very common in projects to handle data with hierarchies. For example, produce could have a<br />
hierarchy structure as SKU -&gt; Sub-Category -&gt; Category -&gt; Department. It is also quite common the<br />
multiple hierarchies could be applied to the same entity. Still using the product example, besides the<br />
category hierarchy, there could be brand hierarchy as SKU-&gt;Sub-Brand-&gt;Brand-&gt;Manufacture, or a theme<br />
hierarchy as SKU-&gt;style-&gt;theme.</p>
<p>For data analysis and reporting, we might need to aggregate data to all the possible levels. Also<br />
possible that some data are only available on some levels. To keep the flexibility and be as general as<br />
possible, we represent the levels with 2 columns &quot;prefix_type&quot; and &quot;prefix_value&quot;. For the product example,<br />
let's use &quot;prod&quot; as the prefix. Then the possible values of <code>prod_type</code> will be all the possible levels<br />
of the hierarchies, e.g. &quot;SKU&quot;, &quot;Sub-Category&quot;, &quot;Manufacture&quot;, &quot;style&quot;, etc. And the <code>prod_value</code> will<br />
be the values of each level.</p>
<p>User will need to define a concrete <code>SmvHierarchies</code> with the 3 product hierarchies, and the<br />
<code>SmvHierarchies</code> class will provides basic aggregation methods.</p>
<h3 id="define-smvhierarchies">Define SmvHierarchies</h3>
<p>Here is an example for Geo hierarchies.</p>
<p>Create the DataSet which has the hierarchy structure</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> ZipRefTable <span class="kw">extends</span> <span class="fu">SmvCsvFile</span>(<span class="st">&quot;path/to/file&quot;</span>) <span class="kw">with</span> SmvOutput {
  ...
}</code></pre></div>
<p>Create a concrete <code>SmvHierarchies</code> using <code>ZipRefTable</code></p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> ZipHierarchies <span class="kw">extends</span> <span class="fu">SmvHierarchies</span>(<span class="st">&quot;geo&quot;</span>,
  <span class="fu">SmvHierarchy</span>(<span class="st">&quot;zip3&quot;</span>, ZipRefTable, Seq(<span class="st">&quot;zip&quot;</span>, <span class="st">&quot;zip3&quot;</span>)),
  <span class="fu">SmvHierarchy</span>(<span class="st">&quot;county&quot;</span>, ZipRefTable, Seq(<span class="st">&quot;zip&quot;</span>, <span class="st">&quot;County&quot;</span>, <span class="st">&quot;State&quot;</span>, <span class="st">&quot;Country&quot;</span>)),
  <span class="fu">SmvHierarchy</span>(<span class="st">&quot;terr&quot;</span>, ZipRefTable, Seq(<span class="st">&quot;zip&quot;</span>, <span class="st">&quot;Territory&quot;</span>, <span class="st">&quot;Devision&quot;</span>, <span class="st">&quot;Region&quot;</span>, <span class="st">&quot;Country&quot;</span>))
)</code></pre></div>
<p>Here,</p>
<ul>
<li><code>geo</code> is the prefix of this <code>SmvHierarchies</code></li>
<li>Different <code>SmvHierarchy</code> defines the hierarchy name, hierarchy map data, and hierarchy sequence (granular to coarse-grained)</li>
<li>The hierarchy maps of different <code>SmvHierarchy</code> could be different</li>
<li>The first element of the hierarchy structure is the join key with whatever data it will applied on</li>
<li>Each hierarchy map will be joined with the data in the order they are listed in the <code>SmvHierarchies</code><br />
definition</li>
</ul>
<h3 id="use-smvhierarchies">Use SmvHierarchies</h3>
<p>Within the user module</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> MyModule <span class="kw">extends</span> <span class="fu">SmvModule</span>(...) {
  <span class="kw">override</span> <span class="kw">def</span> requiresDS = ...
  <span class="kw">override</span> <span class="kw">def</span> requiresAnc = Seq(ZipHierarchies)
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">run</span>(...) {
    ...
    ZipHierarchies.
      <span class="fu">levelRollup</span>(df, Seq(<span class="st">&quot;County&quot;</span>, <span class="st">&quot;State&quot;</span>))(
        <span class="fu">avg</span>($<span class="st">&quot;v1&quot;</span>) as <span class="st">&quot;v1&quot;</span>,
        <span class="fu">avg</span>($<span class="st">&quot;v2&quot;</span>) as <span class="st">&quot;v2&quot;</span>
      )()
  }
}</code></pre></div>
<p><strong>Note</strong> that we need to specify <code>ZipHierarchies</code> within <code>requiresAnc</code> for the user module.</p>
<p>User can extend <code>SmvHierarchies</code> with custom methods. For example</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> ZipHierarchies <span class="kw">extends</span> <span class="fu">SmvHierarchies</span>(<span class="st">&quot;geo&quot;</span>,
  <span class="fu">SmvHierarchy</span>(<span class="st">&quot;zip3&quot;</span>, ZipRefTable, Seq(<span class="st">&quot;zip&quot;</span>, <span class="st">&quot;zip3&quot;</span>)),
  <span class="fu">SmvHierarchy</span>(<span class="st">&quot;county&quot;</span>, ZipRefTable, Seq(<span class="st">&quot;zip&quot;</span>, <span class="st">&quot;County&quot;</span>, <span class="st">&quot;State&quot;</span>, <span class="st">&quot;Country&quot;</span>)),
  <span class="fu">SmvHierarchy</span>(<span class="st">&quot;terr&quot;</span>, ZipRefTable, Seq(<span class="st">&quot;zip&quot;</span>, <span class="st">&quot;Territory&quot;</span>, <span class="st">&quot;Devision&quot;</span>, <span class="st">&quot;Region&quot;</span>, <span class="st">&quot;Country&quot;</span>))
) {
  <span class="kw">def</span> <span class="fu">addNames</span>(df: DataFrame): DataFrame = {...}
}</code></pre></div>
<p>The <code>addNames</code> methods can be used in user modules also.</p>
<h3 id="functions-provided-by-smvhierarchies">Functions provided by <code>SmvHierarchies</code></h3>
<h4 id="levelrollup">levelRollup</h4>
<p>Rollup according to a hierarchy and unpivot with column names</p>
<ul>
<li>prefix_type</li>
<li>prefix_value</li>
</ul>
<p>Example:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">ProdHier.<span class="fu">levelRollup</span>(df, <span class="st">&quot;h1&quot;</span>, <span class="st">&quot;h2&quot;</span>)(<span class="fu">sum</span>($<span class="st">&quot;v1&quot;</span>) as <span class="st">&quot;v1&quot;</span>, ...)()</code></pre></div>
<p>where <code>df</code> is the DataFrame this hierarchy rollup happens. <code>h1</code> and <code>h2</code> are<br />
hierarchy levels will rollup on. The parameter ordering of the levels does<br />
not make any differences.</p>
<p>Assume in the SmvHierarchy object <code>h1</code> is higher level than <code>h2</code>, in other words,<br />
1 <code>h1</code> could have multiple <code>h2</code>s.</p>
<p>For the following data</p>
<pre><code>h1, h2, v1
1,  02, 1.0
1,  02, 2.0
1,  05, 3.0
2,  12, 1.0
2,  13, 2.0</code></pre>
<p>The result will be</p>
<pre><code>prefix_type, prefix_value, v1
h1,        1,          6.0
h1,        2,          3.0
h2,        02,         3.0
h2,        05          3.0
h2,        12,         1.0
h2,        13,         2.0</code></pre>
<p>Please note that first parameter of <code>levelRollup</code> is actually a <code>SmvDFWithKeys</code>, which<br />
a regular <code>DF</code> can implicitly convert to with empty list of keys. To specify keys on a<br />
<code>DF</code>, one can do</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> dfWithKey = df.<span class="fu">smvWithKeys</span>(<span class="st">&quot;k1&quot;</span>)</code></pre></div>
<p>When <code>SmvDFWithKeys</code> is used in <code>levelRollup</code> the rollup will aggregate to each specified<br />
level within each &quot;k1&quot; group.</p>
<h4 id="levelsum">levelSum</h4>
<p>The same as <code>levelRollup</code> but assume all the specified columns are performing<br />
summations.</p>
<p>Example,</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">ProdHier.<span class="fu">levelSum</span>(df, <span class="st">&quot;h1&quot;</span>, <span class="st">&quot;h2&quot;</span>)(<span class="st">&quot;v&quot;</span>)()</code></pre></div>
<h3 id="smvhieropparam">SmvHierOpParam</h3>
<p>The last parameter list of either <code>levelRollup</code> or <code>levelSum</code> is an optional<br />
<code>SmvHierOpParam</code>. It has the following signature</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">SmvHierOpParam</span>(hasName: Boolean, parentHier: Option[String])</code></pre></div>
<p>The default value of <code>SmvHierOpParam</code> of both <code>levelRollup</code> and <code>levelSum</code> is</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">SmvHierOpParam</span>(<span class="kw">false</span>, None)</code></pre></div>
<p>This operation parameter will specify the additional operations of the rollups.</p>
<h4 id="with-name">With Name</h4>
<p>If <code>hasName</code> is <code>true</code>, a <code>prefix_name</code> column will be added in additional to<br />
<code>prefix_type</code> and <code>prefix_value</code> fields.</p>
<p>With in the hierarchymap data, for each hierarchy level, it can have a name field specified.<br />
For an example, a <code>County</code> can have a <code>FIPS</code> code, which will be the <code>geo_value</code>, it could also<br />
have a name, which will be the <code>geo_name</code>.</p>
<pre><code>... ,County,County_name
... ,06073 ,San Diego</code></pre>
<p>The <code>name</code> columns in the hierarchy map data should be named the same way as the <code>value</code> column<br />
with some postfix. The default postfix is <code>_name</code>. In above example, if the level is <code>County</code>,<br />
the column name for <code>value</code> in the map data is <code>County</code>, and the column name for the <code>name</code><br />
will be <code>County_name</code>.</p>
<p>User can specify the postfix when define the <code>SmvHierarchy</code>, as in the following example, the<br />
postfix is <code>Name</code>,</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">SmvHierarchy</span>(<span class="st">&quot;county&quot;</span>, ZipRefTable, Seq(<span class="st">&quot;zip&quot;</span>, <span class="st">&quot;County&quot;</span>, <span class="st">&quot;State&quot;</span>, <span class="st">&quot;Country&quot;</span>), <span class="st">&quot;Name&quot;</span>)</code></pre></div>
<p>When the <code>hasName</code> parameter of <code>SmvHierOpParam</code> is <code>true</code>, the <code>prefix_name</code> column will be added<br />
to the results.</p>
<p>Example</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">MyHier.<span class="fu">levelRollup</span>(df, <span class="st">&quot;zip3&quot;</span>, <span class="st">&quot;County&quot;</span>)(...)(<span class="fu">SmvHierOpParam</span>(<span class="kw">true</span>, None))</code></pre></div>
<p>The result of this example will have rows like the following</p>
<pre><code>geo_type,geo_value,geo_name
County  ,06073    ,San Diego
zip3    ,921      ,null</code></pre>
<p>For the hierarchy levels without name columns in the map data, let's say above example zip3 level<br />
has no name columns defined, the <code>geo_name</code> column will be <code>null</code>.</p>
<h4 id="with-parent-cols">With Parent Cols</h4>
<p>When the <code>parentHier</code> parameter is not <code>None</code>, <code>parent_prefix_type</code>/<code>value</code> fields based on the<br />
specified hierarchy will be added to the results.</p>
<p>For the following hierarchy</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">mvHierarchy</span>(<span class="st">&quot;county&quot;</span>, ZipRefTable, Seq(<span class="st">&quot;zip&quot;</span>, <span class="st">&quot;County&quot;</span>, <span class="st">&quot;State&quot;</span>, <span class="st">&quot;Country&quot;</span>), <span class="st">&quot;Name&quot;</span>)</code></pre></div>
<p>The parent of <code>zip</code> is <code>County</code>, the parent of <code>County</code> is <code>State</code>, etc.</p>
<p>With the following rollup,</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">MyHier.<span class="fu">levelRollup</span>(df, <span class="st">&quot;County&quot;</span>, <span class="st">&quot;State&quot;</span>)(...)(<span class="fu">SmvHierOpParam</span>(<span class="kw">false</span>, Some(<span class="st">&quot;county&quot;</span>)))</code></pre></div>
<p>Part of output could be</p>
<pre><code>geo_type, geo_value, parent_geo_type, parent_geo_value
County,   06073,     State,           CA
State,    CA,        Country,         US</code></pre>
<p>If both <code>hasName</code> and <code>parentHier</code> are specified, a <code>parent_prefix_name</code><br />
column will also be added.</p>
</article>
</body>
</html>
