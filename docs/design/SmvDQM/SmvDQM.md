# SmvDQM Framework

Extracted from issues:
* #176
* #178
* #179

## Use Cases

## Use DQM in SmvApp/SmvModule Framework

### Create DQM
At `SmvDataSet` level, a `dqm` method need to be created with returning an empty SmvDQM. The dqm method could be override by concrete SmvModules or SmvFiles.

```scala
object CoolModule1 extends SmvModule("This is a cool module") {
   override def requiresDS() = Seq(***)
   override def run(***) = {***}
   override def dqm() = SmvDQM().
      add(rule1).
      add(fix1).
      add(policy1).
      ...
}
```

The `SmvDQM` builder interface will be defined in the next session.

Please note that since `dqm` method is on `SmvDataSet` level, for `SmvFile`s, it's better to
create new `SmvFile` objects by extending the base class instead of through a simple constructor
of `SmvFile`, so that the `dqm` method can be override. One step further, `SmvFile` object can
also have a nontrivial `run` method.

### Attach DQM
As long as the dqm is not empty, the `SmvDQM` object will be "attached" to the `DataFrame`
generated by the `run` method of the `SmvDataSet`. It happens when we call `doRun` method of
that `SmvDataSet` from the `SmvApp`:

```
SmvApp::resolveRDD -> SmvDataSet::rdd -> computeRDD -> doRun
```

The `doRun` method then will looks like
```scala
def doRun {
  val resultDf = run()
  df.attachDQM(dqm)
}
```

Please note that when a `SmvDQM` attached to a `DataFrame` the counters and logger in the
`SmvDQM` are not updated yet, since no action happens on the `DataFrame` yet.
We need to collect the results when the first action happens on the df.

### Check DQM results and apply policy
There are 2 types of approaches to collect the results and apply policies:

* For any `SmvDataSet` with none empty `dqm`, force an action. For example, do a count or persist
* Create an monitoring mechanism to keep tracking of the actions on the df created by a `SmvDataSet`

For the "force-an-action" approach, we can either do the action just after attaching dqm in the
`doRun` method:
```scala
def doRun {
  val resultDf = run().attachDQM(dqm)
  resultDf.checkDQM(dqm) // call count at the beginning of checkDQM
  resultDf
}
```

Or we can override `isEphemeral` to false to force an persist and call `checkDQM` after
persisting
```scala
def persist() {
  ...
  rdd.saveAsCsvWithSchema(filePath)
  val rddReadBack = readPersistedFile(prefix).get
  rddReadBack.checkDQM(dqm) // no need to call count within checkDQM
  ...
}
```

The "monitoring" approach is very hard to implement, since although we can keep an eye on all
the actions triggered by the `SmvApp` framework, there is no obvious way for us to keep tracking
of actions within client code.

Let's keep the problem simple and take the "force-an-action" approach.

The only disadvantage is that when the `SmvDataSet` is labeled `isEphemeral`, we still need to
take some actions on it. However, we could honer the flag by not persisting the data.
```scala
def computeRDD() {
  if(isEphemeral) {
    val resultDf = doRun()        // attachDQM is in the doRun method
    resultDf.checkDQMForceAction(dqm)
    resultDf
  } else {
    readPersistedFile() recoverWith {case e =>
      persist(doRun)
      val rddReadBack = readPersistedFile(prefix).get
      rddReadBack.checkDQMNoForceAction(dqm)
      rddReadBack
    }
  }
}
```

### Persist DQM results

By default a `SmvFile` "isEphemeral". In that case as long as the file has none empty dqm, it
will be forced to do an action whenever it is accessed. However since the data file itself does
not changed, the DQM results should be the same. We can actually persist the DQM result in a "filename.hashOfHash.dqm" file, and as long as that file is there, we don't need to run the
`checkDQMForceAction` anymore.

Let's redefined the interface to
```scala
checkDQM(dqm, isForceAction)
```

Within this method, we will try to read the persisted dqm file first and than recover with
a real check.

```scala
private def checkDQMNoForceAction
private def checkDQMForceAction

def checkDQM(dqm, isForceAction) = {
  readPersistedDQM() recoverWith {case e =>
    if(isForceAction) checkDQMForceAction
    else checkDQMNoForceAction
  }
}
```

Please not that the `hashOfHash` is part of the file name, so that if either of the original
file changed or the code of the SmvFile changed (including dqm defination part) the
`readPersistedDQM` will fail and new check will be performed.

### Handle Data read rejections as part of DQM 

## DQM interface (To Be Updated)

### Creating Rules

```scala
val rules = SmvDQM().
    add(Rule($"age" < 150), FailAny, "ageLT150").
    add(BoundRule($"age", 1, 150), FailCount(10)).
    add(Fix( $"age" > 150, lit(150) as 'age), "ageFix150").
    add(BoundFix($"age", 1, 150), "ageFix1-150").
    ...
```

The `SmvDQM` is a builder which takes `add` method with 3 signatures
* `add(rule: DQMRule, rulePolicy: DQMRulePolicy = FailNone, name: String = null)`
* `add(fix: DQMFix, name: String = null)`
* `add(policy: DQMPolicy, name: String = null)`

A `DQMRule` is applied on records. If any record violates the Rule, the entire record will be rejected. A `DQMFix` is applied to a cell of a record and fix the cell while keep the record. A `DQMPolicy` is applied on the entire DF with the DQMResult (see below).

A `DQMRulePolicy` is a `DQMPolicy` which only depends on the specific Rule's result. It has 4 case class/objects:
* `FailNone` - policy check never fails even if some records are rejected
* `FailAny` - policy check fails if any record get rejected by the CheckRule
* `FailCount(n)` - policy check fails if more than n records get rejected by the CheckRule
* `FailPercent(r)` - policy check fails is more than r percent records get rejected by the CheckRule. The percentage `r` is a float between 0 and 1.

For now we only implement 2 case classes
* `TotalFailCountPolicy(n)`
* `TotalFailPercentPolicy(r)`

Which will combine all the rule rejected counts and check the policies. For example, if in total there are 2 rules defined, one for checking the `age` field and the other checking `amt` field, we can defined a `TotalFailCountPolicy(1000)`. The `DF` will fail the policy if add up together there are more than 1000 records get rejected by the 2 rules.

We can extend DQMRule and DQMFix for specific common cases to make the code clearer.  See example below. Note: only the rules are shown below, there would be an equivalent "Fix" method that takes a default value.
```scala
val rules = SmvDQM().
    add(FormatRule($"age", """^[A-Z]""".r)).
    add(SetRule($"gender", Seq("M", "F"))).
    ...
```

### User defined Rules, Fixes and Policies

A Rule can be defined with a `Column` which returns a BooleanType. So user can extends `DQMRule` to define new rules. For example,
```scala
case class DoubleOpenBoundRule(c: Column, upper: Double, lower: Double)
  extends DQMRule(c < lit(upper) && c > lit(lower))
```

User defined `DQMFix` interface
```scala
case class SetFix(c: Column, validVals: Seq[String], default: String)
  extends DQMFix(! c.in(validVals.map{s => lit(s)}: _*), lit(default))
```

User defined `DQMPolicy` interface
```scala
DQMPolicy((DataFrame, DQMLogger) => Boolean)
```

### Applying the DQM
Once the DQM (set of rules, fixes, policies) have been created, they can be applied to a `DataFrame`.  As a matter of fact, the same set of rules can be applied to multiple `DataFrame`s.

However, since we want to avoid introducing an extra *Action* to the `DataFrame` just for DQM, internally we will split the applying DQM to 2 steps:
* attachDQM, and
* checkDQMPolicy

where the first step will simply apply the Rules and Fixes to the DF as projections and filters (*Transformations*, instead of *Actions*).

After that user could trigger an *Action*, within SmvApp framework it will be the persist step of a SmvModule which depends on the DF. After the action, `checkDQMPolicy` should be called, which will collect the results from the Rules and Fixes and also potentially apply checks agains any operation on the output DF.

In between of the `attachDQM` and `checkDQMPolicy` methods, a `DQMLogger` objects will be used to pass the results.

#### `DQMLogger`
The following counters and logger are needed to store the DQM results
* recordCounter
* fixCounter
* rejectCounter
* rejectLog

All of them are accumulators. Counters are accumulators on Map, and Loggers are accumulator on List[String].

#### `attachDQM` (private[smv])
```scala
val resDf = df.applyDQM(dqm, dqmLogger)
```
Applying the DQM is a transformation on the df will not force an action.  The results of the DQM will be stored in the `dqmLogger`.

#### `checkDQMPolicie` (private[smv])
DQM rule and fix results, which stored in the `DQMLogger`, will be checked when action happened on a `DataFrame`.
```scala
val dqmRes = df.checkPolicy(dqm, dqmLogger)
```
Depending on the policies, a `checkPolicy` method could be a transformation or an action.
By splitting `applyDQM` and `checkPolicy`, we don't need to force an action just for DQM check. Instead, we can wait for a downstream action and then call the `checkPolicy`. In case that policies in the DQM are all based on the results in the `dqmLogger` we can save an unnecessary action.

#### `applyDQM`
We will provide a single method, `applyDQM`, to users with combining the `attachDQM` and `checkDQMPolicy` methods. In this method, we will force an action (could be a `count`) in between of those 2 methods.

#### DQMResult
The returned `DQMResult` object will have the following attributes:
* `passed: Boolean` - whether the DQM is passed
* `errorMessages: Seq[(String, String)]` - list of policy name - error message pair on failed policies
